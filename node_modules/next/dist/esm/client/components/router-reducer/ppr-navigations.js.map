{"version":3,"sources":["../../../../../src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshUrl: string | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  shouldRefreshDynamicData: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshUrl = null\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouterState,\n    shouldRefreshDynamicData,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    parentRefreshUrl,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  shouldRefreshDynamicData: boolean,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  parentRefreshUrl: string | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = newRouterState[0]\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouterState)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterState,\n      oldCacheNode,\n      shouldRefreshDynamicData,\n      seedData,\n      seedHead,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newRouterStateChildren = newRouterState[1]\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const isRootLayout = newRouterState[4] === true\n  const childDidFindRootLayout = didFindRootLayout || isRootLayout\n\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const newParallelRoutes = new Map(\n    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n  )\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: ReadyCacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n    needsDynamicRequest = false\n  } else if (seedData !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt\n    )\n    needsDynamicRequest = true\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const href = newRouterState[2]\n  const refreshUrl =\n    typeof href === 'string' && newRouterState[3] === 'refresh'\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        href\n      : // Inherit the refresh URL from the parent.\n        parentRefreshUrl\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshUrl !== null) {\n    accumulateRefreshUrl(accumulation, refreshUrl)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    let newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    if (oldRouterStateChild === undefined) {\n      // This should never happen, but if it does, it suggests a malformed\n      // server response. Trigger a full-page navigation.\n      return null\n    }\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n\n    let seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    let prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    let newSegmentChild = newRouterStateChild[0]\n    let seedHeadChild = seedHead\n    let prefetchHeadChild = prefetchHead\n    let isPrefetchHeadPartialChild = isPrefetchHeadPartial\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is a \"default\" segment. These are never sent by the server during\n      // a soft navigation; instead, the client reuses whatever segment was\n      // already active in that slot on the previous route.\n      newRouterStateChild = reuseActiveSegmentInDefaultSlot(\n        oldUrl,\n        oldRouterStateChild\n      )\n      newSegmentChild = newRouterStateChild[0]\n\n      // Since we're switching to a different route tree, these are no\n      // longer valid, because they correspond to the outer tree.\n      seedDataChild = null\n      seedHeadChild = null\n      prefetchDataChild = null\n      prefetchHeadChild = null\n      isPrefetchHeadPartialChild = false\n    }\n\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = updateCacheNodeOnNavigation(\n      navigatedAt,\n      oldUrl,\n      oldCacheNodeChild,\n      oldRouterStateChild,\n      newRouterStateChild,\n      shouldRefreshDynamicData,\n      childDidFindRootLayout,\n      seedDataChild ?? null,\n      seedHeadChild,\n      prefetchDataChild ?? null,\n      prefetchHeadChild,\n      isPrefetchHeadPartialChild,\n      isSamePageNavigation,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      refreshUrl,\n      accumulation\n    )\n\n    if (taskChild === null) {\n      // One of the child tasks discovered a change to the root layout.\n      // Immediately unwind from this recursive traversal. This will trigger a\n      // full-page navigation.\n      return null\n    }\n\n    // Recursively propagate up the child tasks.\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    // The child tree's route state may be different from the prefetched\n    // route sent by the server. We need to clone it as we traverse back up\n    // the tree.\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      // Something in the child tree is dynamic.\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshUrl,\n    // NavigationTasks only have children if neither itself nor any of its\n    // parents require a dynamic request. When writing dynamic data into the\n    // tree, we can skip over any tasks that have children.\n    // TODO: This is probably an unncessary optimization. The task tree only\n    // lives for as long as the navigation request, anyway.\n    children:\n      parentNeedsDynamicRequest || needsDynamicRequest ? null : taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouterState: FlightRouterState,\n  oldCacheNode: CacheNode | void,\n  shouldRefreshDynamicData: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  parentSegmentPath: FlightSegmentPath,\n  parentParallelRouteKey: string,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = newRouterState[0]\n  const segmentPath = parentSegmentPath.concat([\n    parentParallelRouteKey,\n    newSegment,\n  ])\n\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n  const oldParallelRoutes =\n    oldCacheNode !== undefined ? oldCacheNode.parallelRoutes : undefined\n  const newParallelRoutes = new Map(\n    shouldRefreshDynamicData ? undefined : oldParallelRoutes\n  )\n  const isLeafSegment = Object.keys(newRouterStateChildren).length === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  let newCacheNode: ReadyCacheNode\n  let needsDynamicRequest: boolean\n  if (\n    !shouldRefreshDynamicData &&\n    oldCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    // TODO: We should use this same logic for popstate navigations, replacing\n    // the `updateCacheNodeOnPopstateRestoration` function. That way we can\n    // handle the case where the data is missing here, like we would for a\n    // normal navigation, rather than rely on the lazy fetch in LazyRouter.\n    oldCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // Reuse the existing CacheNode\n    newCacheNode = reuseDynamicCacheNode(oldCacheNode, newParallelRoutes)\n    needsDynamicRequest = false\n  } else if (seedData !== null) {\n    // If this navigation was the result of an action, then check if the\n    // server sent back data in the action response. We should favor using\n    // that, rather than performing a separate request. This is both better\n    // for performance and it's more likely to be consistent with any\n    // writes that were just performed by the action, compared to a\n    // separate request.\n    const seedRsc = seedData[0]\n    const seedLoading = seedData[2]\n    const isSeedRscPartial = false\n    const isSeedHeadPartial = seedHead === null\n    newCacheNode = readCacheNodeFromSeedData(\n      seedRsc,\n      seedLoading,\n      isSeedRscPartial,\n      seedHead,\n      isSeedHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest = isLeafSegment && isSeedHeadPartial\n  } else if (prefetchData !== null) {\n    // Consult the prefetch cache.\n    const prefetchRsc = prefetchData[0]\n    const prefetchLoading = prefetchData[2]\n    const isPrefetchRSCPartial = prefetchData[3]\n    newCacheNode = readCacheNodeFromSeedData(\n      prefetchRsc,\n      prefetchLoading,\n      isPrefetchRSCPartial,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      isLeafSegment,\n      newParallelRoutes,\n      navigatedAt\n    )\n    needsDynamicRequest =\n      isPrefetchRSCPartial || (isLeafSegment && isPrefetchHeadPartial)\n  } else {\n    // Spawn a request to fetch new data from the server.\n    newCacheNode = spawnNewCacheNode(\n      newParallelRoutes,\n      isLeafSegment,\n      navigatedAt\n    )\n    needsDynamicRequest = true\n  }\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild =\n      oldParallelRoutes !== undefined\n        ? oldParallelRoutes.get(parallelRouteKey)\n        : undefined\n    const seedDataChild: CacheNodeSeedData | void | null =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    const taskChild = createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouterStateChild,\n      oldCacheNodeChild,\n      shouldRefreshDynamicData,\n      seedDataChild ?? null,\n      seedHead,\n      prefetchDataChild ?? null,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      parallelRouteKey,\n      parentNeedsDynamicRequest || needsDynamicRequest,\n      accumulation\n    )\n\n    if (taskChildren === null) {\n      taskChildren = new Map()\n    }\n    taskChildren.set(parallelRouteKey, taskChild)\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map(\n        shouldRefreshDynamicData ? undefined : oldSegmentMapChild\n      )\n      newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n      newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n    }\n\n    const taskChildRoute = taskChild.route\n    patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n    if (dynamicRequestTreeChild !== null) {\n      childNeedsDynamicRequest = true\n      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n    } else {\n      dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n    }\n  }\n\n  return {\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshUrl: null,\n    children:\n      parentNeedsDynamicRequest || needsDynamicRequest ? null : taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshUrl: string\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): FlightRouterState {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return reusedRouterState\n}\n\nfunction reuseDynamicCacheNode(\n  existingCacheNode: CacheNode,\n  parallelRoutes: Map<string, ChildSegmentMap>\n): ReadyCacheNode {\n  // Clone an existing CacheNode's data, with (possibly) new children.\n  const cacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: existingCacheNode.rsc,\n    prefetchRsc: existingCacheNode.prefetchRsc,\n    head: existingCacheNode.head,\n    prefetchHead: existingCacheNode.prefetchHead,\n    loading: existingCacheNode.loading,\n\n    parallelRoutes,\n\n    // Don't update the navigatedAt timestamp, since we're reusing\n    // existing data.\n    navigatedAt: existingCacheNode.navigatedAt,\n  }\n  return cacheNode\n}\n\nfunction readCacheNodeFromSeedData(\n  prefetchRsc: React.ReactNode,\n  prefetchLoading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPrefetchRSCPartial: boolean,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isPageSegment: boolean,\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  navigatedAt: number\n): ReadyCacheNode {\n  // TODO: Currently this is threaded through the navigation logic using the\n  // CacheNodeSeedData type, but in the future this will read directly from\n  // the Segment Cache. See readRenderSnapshotFromCache.\n\n  let rsc: React.ReactNode\n  if (isPrefetchRSCPartial) {\n    // The prefetched data contains dynamic holes. Create a pending promise that\n    // will be fulfilled when the dynamic data is received from the server.\n    rsc = createDeferredRsc()\n  } else {\n    // The prefetched data is complete. Use it directly.\n    rsc = prefetchRsc\n  }\n\n  // If this is a page segment, also read the head.\n  let resolvedPrefetchHead: HeadData | null\n  let resolvedHead: HeadData | null\n  if (isPageSegment) {\n    resolvedPrefetchHead = prefetchHead\n    if (isPrefetchHeadPartial) {\n      resolvedHead = createDeferredRsc()\n    } else {\n      resolvedHead = prefetchHead\n    }\n  } else {\n    resolvedPrefetchHead = null\n    resolvedHead = null\n  }\n\n  const cacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc,\n    head: resolvedHead,\n    prefetchHead: resolvedPrefetchHead,\n    // TODO: Technically, a loading boundary could contain dynamic data. We\n    // should have separate `loading` and `prefetchLoading` fields to handle\n    // this, like we do for the segment data and head.\n    loading: prefetchLoading,\n    parallelRoutes,\n    navigatedAt,\n  }\n\n  return cacheNode\n}\n\nfunction spawnNewCacheNode(\n  parallelRoutes: Map<string, ChildSegmentMap>,\n  isLeafSegment: boolean,\n  navigatedAt: number\n): ReadyCacheNode {\n  const cacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: createDeferredRsc(),\n    prefetchRsc: null,\n    head: isLeafSegment ? createDeferredRsc() : null,\n    prefetchHead: null,\n    loading: createDeferredRsc<LoadingModuleData>(),\n    parallelRoutes,\n    navigatedAt,\n  }\n  return cacheNode\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  url: URL,\n  nextUrl: string | null,\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  // TODO: Rather than pass this into listenForDynamicRequest, we should seed\n  // the data into the CacheNode tree during the first traversal. Similar to\n  // what we will do for seeding navigations from a Server Action.\n  existingDynamicRequestPromise: Promise<FetchServerResponseResult> | null,\n  accumulation: NavigationRequestAccumulation\n): void {\n  const requestPromises = []\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    // Normal case. All the data can be fetched from the same URL.\n    if (existingDynamicRequestPromise !== null) {\n      // A dynamic request was already initiated. This can happen if the route\n      // tree was not already prefetched/cached before navigation.\n      requestPromises.push(\n        attachServerResponseListener(task, existingDynamicRequestPromise)\n      )\n    } else {\n      // Initiate a new dynamic request.\n      requestPromises.push(\n        attachServerResponseListener(\n          task,\n          fetchServerResponse(url, {\n            flightRouterState: dynamicRequestTree,\n            nextUrl,\n          })\n        )\n      )\n    }\n  } else {\n    // This is a refresh navigation, and there are multiple URLs that we need to\n    // request the data from. This happens when a \"default\" parallel route slot\n    // is present in the tree, and its data cannot be fetched from the current\n    // route. We need to split the combined dynamic request tree into separate\n    // requests per URL.\n    //\n    // First construct a request tree for the main URL. This will prune away\n    // the parts of the tree that are not present in the current route. (`null`\n    // as the second argument is used to represent the main URL.)\n    if (existingDynamicRequestPromise !== null) {\n      // A dynamic request was already initiated. This can happen if the route\n      // tree was not already prefetched/cached before navigation.\n      requestPromises.push(\n        attachServerResponseListener(task, existingDynamicRequestPromise)\n      )\n    } else {\n      // Initiate a new dynamic request.\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const primaryDynamicRequestTree = splitTaskByURL(task, null)\n      const primaryDynamicRequestTree = dynamicRequestTree\n      if (primaryDynamicRequestTree !== null) {\n        requestPromises.push(\n          attachServerResponseListener(\n            task,\n            fetchServerResponse(url, {\n              flightRouterState: primaryDynamicRequestTree,\n              nextUrl,\n            })\n          )\n        )\n      }\n    }\n    // Then construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    const canonicalUrl = createHrefFromUrl(url)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        requestPromises.push(\n          attachServerResponseListener(\n            task,\n            fetchServerResponse(new URL(refreshUrl, url.origin), {\n              flightRouterState: scopedDynamicRequestTree,\n              nextUrl,\n            })\n          )\n        )\n      }\n    }\n  }\n\n  // Once we've exhausted all the data we received from the server, if there are\n  // any remaining pending tasks in the tree, abort them. As a last ditch\n  // effort, this will trigger the \"old\" fetching path (server-patch-reducer)\n  // in LayoutRouter, though in the future we'll remove server-patch-reducer\n  // and handle server failures using some more robust mechanism. Perhaps by\n  // throwing a special offline error, or by triggering an MPA refresh.\n  Promise.all(requestPromises).then(\n    () => abortTask(task, null, null),\n    () => abortTask(task, null, null)\n  )\n}\n\nfunction attachServerResponseListener(\n  task: NavigationTask,\n  requestPromise: Promise<FetchServerResponseResult>\n): Promise<void> {\n  return requestPromise.then((result) => {\n    if (typeof result === 'string') {\n      // Happens when navigating to page in `pages` from `app`. We shouldn't\n      // get here because should have already handled this during\n      // the prefetch.\n      return\n    }\n    const { flightData, debugInfo } = result\n    for (const normalizedFlightData of flightData) {\n      const {\n        segmentPath,\n        tree: serverRouterState,\n        seedData: dynamicData,\n        head: dynamicHead,\n      } = normalizedFlightData\n\n      if (!dynamicData) {\n        // This shouldn't happen. PPR should always send back a response.\n        // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n        // this might return null.\n        continue\n      }\n\n      writeDynamicDataIntoPendingTask(\n        task,\n        segmentPath,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n    }\n  })\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: NavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: NavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverChildren) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0]) &&\n        dataChild !== undefined &&\n        dataChild !== null\n      ) {\n        finishPendingCacheNode(\n          cacheNodeChild,\n          taskStateChild,\n          serverStateChild,\n          dataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n  //\n  // TODO: Delete this function and instead move the logic into the normal\n  // navigation path (updateCacheNodeOnNavigation) to ensure we handle all the\n  // same cases. The only difference is that whenever a segment is missing, we\n  // should always check for existing dynamic data rather than spawning a new\n  // request. We can handle this using the same branch that handles stale\n  // dynamic data (see createCacheNodeOnNavigation).\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","NOT_FOUND_SEGMENT_KEY","matchSegment","createHrefFromUrl","createRouterCacheKey","fetchServerResponse","isNavigatingToNewRootLayout","DYNAMIC_STALETIME_MS","startPPRNavigation","navigatedAt","oldUrl","oldCacheNode","oldRouterState","newRouterState","shouldRefreshDynamicData","seedData","seedHead","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","accumulation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshUrl","updateCacheNodeOnNavigation","undefined","parentSegmentPath","parentParallelRouteKey","oldSegment","newSegment","createCacheNodeOnNavigation","segmentPath","concat","newRouterStateChildren","oldRouterStateChildren","seedDataChildren","prefetchDataChildren","isRootLayout","childDidFindRootLayout","oldParallelRoutes","parallelRoutes","newParallelRoutes","Map","isLeafSegment","Object","keys","length","newCacheNode","needsDynamicRequest","reuseDynamicCacheNode","seedRsc","seedLoading","isSeedRscPartial","isSeedHeadPartial","readCacheNodeFromSeedData","prefetchRsc","prefetchLoading","isPrefetchRSCPartial","spawnNewCacheNode","href","refreshUrl","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","seedDataChild","prefetchDataChild","newSegmentChild","seedHeadChild","prefetchHeadChild","isPrefetchHeadPartialChild","reuseActiveSegmentInDefaultSlot","newSegmentKeyChild","oldCacheNodeChild","taskChild","set","newCacheNodeChild","node","newSegmentMapChild","taskChildRoute","route","dynamicRequestTreeChild","dynamicRequestTree","patchRouterStateWithNewChildren","createDynamicRequestTree","children","scrollableSegments","push","baseRouterState","newChildren","clone","separateRefreshUrls","Set","add","reusedRouterState","oldRefreshMarker","existingCacheNode","cacheNode","lazyData","rsc","head","loading","isPageSegment","createDeferredRsc","resolvedPrefetchHead","resolvedHead","listenForDynamicRequest","url","nextUrl","task","existingDynamicRequestPromise","requestPromises","attachServerResponseListener","flightRouterState","primaryDynamicRequestTree","canonicalUrl","scopedDynamicRequestTree","URL","origin","Promise","all","then","abortTask","requestPromise","result","flightData","debugInfo","normalizedFlightData","tree","serverRouterState","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","dynamicSegmentData","isDeferredRsc","resolve","dynamicLoading","error","abortPendingCacheNode","values","routerState","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","reject","updateCacheNodeOnPopstateRestoration","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","res","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","_debugInfo"],"mappings":"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","ignoreList":[0]}