{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleNavigationResult } from './navigate-reducer'\nimport { navigateToSeededRoute } from '../../segment-cache/navigation'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n  // only client-side refreshes will have this behavior; the server-side\n  // `refresh` should send new data without purging the prefetch cache.\n  const currentNextUrl = state.nextUrl\n  const currentRouterState = state.tree\n  revalidateEntireCache(currentNextUrl, currentRouterState)\n\n  // We always send the last next-url, not the current when performing a dynamic\n  // request. This is because we update the next-url after a navigation, but we\n  // want the same interception route to be matched that used the last next-url.\n  const nextUrlForRefresh = hasInterceptionRouteInCurrentTree(state.tree)\n    ? state.previousNextUrl || currentNextUrl\n    : null\n\n  // A refresh is modeled as a navigation to the current URL, but where any\n  // existing dynamic data (including in shared layouts) is re-fetched.\n  const currentUrl = new URL(state.canonicalUrl, action.origin)\n  const url = currentUrl\n  const currentFlightRouterState = state.tree\n  const shouldScroll = true\n  const shouldRefreshDynamicData = true\n\n  const seedFlightRouterState = state.tree\n  const seedRenderedSearch = state.renderedSearch\n  const seedData = null\n  const seedHead = null\n\n  const result = navigateToSeededRoute(\n    url,\n    currentUrl,\n    state.cache,\n    currentFlightRouterState,\n    seedFlightRouterState,\n    seedRenderedSearch,\n    seedData,\n    seedHead,\n    shouldRefreshDynamicData,\n    nextUrlForRefresh,\n    shouldScroll\n  )\n\n  const mutable: Mutable = {}\n  mutable.preserveCustomHistoryState = false\n\n  return handleNavigationResult(currentUrl, state, mutable, false, result)\n}\n"],"names":["refreshReducer","state","action","currentNextUrl","nextUrl","currentRouterState","tree","revalidateEntireCache","nextUrlForRefresh","hasInterceptionRouteInCurrentTree","previousNextUrl","currentUrl","URL","canonicalUrl","origin","url","currentFlightRouterState","shouldScroll","shouldRefreshDynamicData","seedFlightRouterState","seedRenderedSearch","renderedSearch","seedData","seedHead","result","navigateToSeededRoute","cache","mutable","preserveCustomHistoryState","handleNavigationResult"],"mappings":";;;;+BAWgBA;;;eAAAA;;;iCALuB;4BACD;uBACA;mDACY;AAE3C,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,0EAA0E;IAC1E,sEAAsE;IACtE,qEAAqE;IACrE,MAAMC,iBAAiBF,MAAMG,OAAO;IACpC,MAAMC,qBAAqBJ,MAAMK,IAAI;IACrCC,IAAAA,4BAAqB,EAACJ,gBAAgBE;IAEtC,8EAA8E;IAC9E,6EAA6E;IAC7E,8EAA8E;IAC9E,MAAMG,oBAAoBC,IAAAA,oEAAiC,EAACR,MAAMK,IAAI,IAClEL,MAAMS,eAAe,IAAIP,iBACzB;IAEJ,yEAAyE;IACzE,qEAAqE;IACrE,MAAMQ,aAAa,IAAIC,IAAIX,MAAMY,YAAY,EAAEX,OAAOY,MAAM;IAC5D,MAAMC,MAAMJ;IACZ,MAAMK,2BAA2Bf,MAAMK,IAAI;IAC3C,MAAMW,eAAe;IACrB,MAAMC,2BAA2B;IAEjC,MAAMC,wBAAwBlB,MAAMK,IAAI;IACxC,MAAMc,qBAAqBnB,MAAMoB,cAAc;IAC/C,MAAMC,WAAW;IACjB,MAAMC,WAAW;IAEjB,MAAMC,SAASC,IAAAA,iCAAqB,EAClCV,KACAJ,YACAV,MAAMyB,KAAK,EACXV,0BACAG,uBACAC,oBACAE,UACAC,UACAL,0BACAV,mBACAS;IAGF,MAAMU,UAAmB,CAAC;IAC1BA,QAAQC,0BAA0B,GAAG;IAErC,OAAOC,IAAAA,uCAAsB,EAAClB,YAAYV,OAAO0B,SAAS,OAAOH;AACnE","ignoreList":[0]}